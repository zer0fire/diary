### this 复习

* this 的定义和作用：this 是 JS 的面向对象编程中的关键字，通常用于指向类实例化后的对象本身，但由于设计糟糕，所以要分情况考虑
* this 的特性：call、apply、bind 的第一个参数都能改变方法的 this，注意绑定过的函数的结果不能重新绑定
* this 在不同情况下的表现
  * 类内：实例化后，指向实例化的对象本身
  * 对象的方法：指向对象本身，注意如果对象的方法被传给一个外部的变量，那么this指向也就变成外部那个变量本身的 this 指向，也不要嵌套，嵌套在里层的普通函数指向的也是全局变量
  * function 函数内：指向全局变量，如果用于当作构造函数，那么也是实例化的对象本身
  * 箭头函数内：静态作用域，指向函数外层最近一层的this，如果箭头函数是在全局定义，那么就指向全局对象（window、global）
  * 全局作用域，指向全局对象（window、global）

### 事件模型

* 事件对象：在绑定事件处理器后，事件处理器在调用时会被传入事件对象event，并且浏览器会创建一个window.event，在处理完成后销毁

* 冒泡：祖先元素上的事件处理器会在后代元素发生相应事件后也会被调用，并且一直逐级往外抛出直到document和window上，可以用event.stopPropagation停止冒泡
* 捕获：与冒泡相反，组件元素在事件捕获阶段就触发，使用stopImmediatelyPropagation阻止继续捕获，因为即便当前的发生的捕获被阻止了，其他元素还会继续往下传播事件
* 目标阶段：事件在真正发生的节点上被监听到并运行事件处理器
* 事件代理/事件委托：将事件绑定在祖先元素上，使用event.target判断后代元素，简化对后代元素事件的绑定
* 模型：捕获阶段-> 目标阶段 -> 冒泡阶段

### 事件循环

* eventloop：先进先出队列，分成不同阶段执行，需要消耗完当前的队列或者回调执行到最大值极限（单次进入阶段时执行回调的上限，会有个很大的上限），才会接着下一个阶段
* 微任务宏任务：微任务运行在阶段的间隙，随时插入，队列会直接执行且不会循环，宏任务运行在阶段之中，不可随时插入，因此会循环再执行（浏览器和Node 的对此的处理稍有不同）
  * process.nextTick微任务，因此在各个阶段的间隙运行
  * then也是微任务，但规定在process.nextTick后面
  * 浏览器有setTimeout和
* 几个阶段：
  * timers：执行 setTimeout 和 setInterval，时间限制，超时以后才尽快执行，因此不会精确（会受上一次poll的影响）
  * pending ：系统操作的回调，比如 TCP errors，比如 TCP 报错 ECONNREFUSED
  * idle，node 内部的一些异步操作
  * poll：找回新IO事件（估计就是接入新的IO）（等待着可以执行的东西执行），比如fs.readFile 的回调，两个步骤：计算 timers 最多需要等待的时间，并处理队列，如果队列不为空，就执行直到队列完成或队列极限；如果队列为空：有 setImmediately，那么离开并执行 check 阶段，如果没有，那么就在这等着直到有新的 callback 进入就单线程执行掉，直到等待时间结束；注意如果在回调里面再放一个该阶段的回调也只会在下阶段执行，符合宏任务的特点 
  * check：执行 setImmediately 等
  * close callback：关闭的回调，比如`socket.on('close', ...)`
* await 会把得到的结果包装成 Promise，await 之后的语句会当做 Promise.then() 里的语句执行
* 宏任务，setTimout、setInterval、setImmediately、requestAnamtionFrame
* 微任务，process.nextTick、Promise.then、MutaionObserver
* `NodeJS` 和浏览器里的 `then` 不太一样，Node 里面的 `process.nextTick` 优先级明显比 `then` 高，有待文档或 stackoverflow 里求证

### 一文搞懂浏览器缓存策略

1. 缓存的判断策略

   * 主要包含以下三种策略：**存储策略**、**过期策略**、**协商策略**

   * 存储策略发生在收到请求响应后，用于决定是否缓存相应资源

   * 过期策略发生在请求前，用于判断缓存是否过期

   * 协商策略发生在请求中，用于判断缓存资源是否更新（比如 304 Not Modified ）

   * ![](E:\1.FrontEnd\浏览器缓存流程.jpg)

   * 浏览器发起请求 -> 是否有缓存 -> 向服务器请求资源 -> **存储策略**：响应内容存入缓存 -> 载入资源

     ​			|														|																					|

     **过期策略**：判断缓存是否过期 -> **协商策略**：向服务端发起验证，验证资源是否有效 -> 304响应

     * 怎么判断过期？计算文件日期（Exprires等响应头）？怎么发起验证？另外的验证资源请求？怎么发起（不发起另外的，直接就是根据响应做判断）？如果304响应又该怎么做（存储策略响应）？怎么存入，存到哪里（Chrome是根据派生和主资源的方式方式存到disk或memory中）？

   * 根据浏览器中访问资源方式的不同也会导致判断流程的不同，**判断流程会根据不同方式跳过一些流程**

   * 浏览器访问资源的方式主要是以下7种

     1. 新标签/地址栏回车
     2. 链接跳转(**window.location 赋值或 replace 算吗？**)（应该算，需要验证）
     3. 前进后退
     4. 收藏栏打开
     5. window.open 打开新窗口
     6. 刷新（F5）
     7. 强制刷新（Ctrl+F5）

   * 前面5种正常流程，刷新直接到协商策略，强制刷新直接请求资源

   * Chrome地址栏不改变内容回车想相当于刷新，FireFox等别的不变
   * 主资源和派生资源：主资源是地址栏输入的URL请求返回的资源（**有什么呢？HTML？**），派生资源是主资源所引用的JS、CSS、图片等资源（**我记得有种常见的是吧JS、CSS、图片等的名称中加一串hash，说是可以防止缓存，这是为什么呢？**），Chrome刷新时，只有主资源缓存方式走上述刷新流程，派生资源的缓存应用方式与新标签打开类似，会判断是否过期。强缓存生效时的区别在于新标签打开为`from disk cache`，而当前页面刷新派生资源`from memory cache`
   * FireFox（Gecko），EdgeHTML(Trident，后来改成webkit了)，Blink是现在魔改版的webkit

2. 必知必会的缓存基础

   * 与缓存相关的HTTP字段（10个（9个？））（包含存储策略、过期策略、协商策略、请求头、响应头）

| Key                 | 描述                                                         | 存储策略 | 过期策略 | 协商策略 | 请求头 | 响应头 |
| ------------------- | ------------------------------------------------------------ | -------- | -------- | -------- | ------ | ------ |
| Expires             | 指定缓存的过期时间，值为某一时刻(绝对时间)。在指定时刻后过期 | √        | √        |          |        | √      |
| Cache-Control       | 指定缓存机制                                                 | √        | √        |          | √      | √      |
| Pragma              | 指定缓存机制( HTTP1.0 字段)                                  |          |          |          | √      |        |
| Last-Modified       | 资源最后修改时间( 有可能触发启发式缓存 )                     | 乄       |          | √        |        | √      |
| If-Modified-Since   | 缓存协商校验字段，为上次请求收到的 Last-Modified 的值        |          |          | √        | √      |        |
| If-Unmodified-Since | 缓存协商校验字段，为上次请求收到的 Last-Modified 的值，但处理方式与上面 Modified 头的相反 |          |          | √        | √      |        |
| ETag                | 请求资源的唯一表示字符串                                     |          |          | √        |        | √      |
| If-Match            | 缓存协商校验字段，请求资源的唯一标识字符串，为上次收到的 ETag 的值 |          |          | √        | √      |        |
| If-None-Match       | 缓存协商校验字段，请求资源的唯一标识字符串，为上次收到的 ETag 的值，但处理方式与 If-Match 相反 |          |          | √        | √      |        |

* 关系：Expires、Cache-Control 是属于通用的存储和过期策略，Cache-Control 更是在请求头和响应头都存在；Last-Modified 响应头对应 If-Modified-Since 和 If-Unmodified-Since 两个请求头；ETag 响应头对应 Last-Match 和 Last-None-Match 两个响应头，他们基本都对应了协商策略，Last-Modified 可能触发启发式缓存从而缓存文件
* 缓存 又分强缓存和弱缓存（协商缓存）。强缓存包括 `Expires` 和 `Cache-Control`，主要是在过期策略生效时应用的缓存。弱缓存包括 `Last-Modified` 和 `ETag` ，是在协商策略后应用的缓存。强弱缓存之间的主要区别在于获取资源时是否会发送请求
* Expires：指定缓存的过期时间，绝对时间，RFC 2616 建议最大值不要超过 1 年，类似于下文，出现在响应头
  * 语法：`Expires: Sat Oct 20 2018 00:00:00 GMT+0800 (CST)` （时间点）
* Cache-Control：指定资源的缓存机制，可以同时在请求头和响应头中设定，涉及的是存储策略和过期策略
  * 语法：`Cache-Control: cache-directive[, cache-directive]`。`cache-directive` 为缓存指令，大小写不明感，共有 12 个与 HTTP 缓存标准相关，其中 7 种是请求指令，9 种是响应指令，多个指令 `,` 分割

| Key                   | 描述                                                         | 存储策略 | 过期策略 | 请求字段 | 响应字段 |
| --------------------- | ------------------------------------------------------------ | -------- | -------- | -------- | -------- |
|                       | 可缓存性相关                                                 |          |          |          |          |
| `public`              | 资源在客户端和代理服务器缓存                                 | √        |          |          | √        |
| `private`             | 资源仅在客户端缓存，代理服务器不缓存                         | √        |          |          | √        |
| `no-cache`            | 资源被缓存，但立即过期，下次访问时强制向服务器验证有效性。相当于max-age:0,must-revalidate | √        | √        | √        | √        |
|                       | 过期相关                                                     |          |          |          |          |
| `max-age=<seconds>`   | **在请求头中**：指出客户端不接受有效时间大于指定时间的缓存；**在响应头中**：规定资源最大的新鲜时间，指定时间后会过期，单位为秒 | √        | √        | √        | √        |
| `s-maxage=<seconds>`  | 同上，但只对代理服务器生效，且只有响应头，如果是 `privte` 缓存，会忽略该字段。会覆盖 `max-age` 指令和 `Expires` 响应头 | √        | √        |          | √        |
| `max-stale=<seconds>` | 指定时间内，及时缓存过时，资源仍然有效                       |          | √        | √        |          |
| `min-fresh=<seconds>` | 缓存的资源至少要保持指定时间的新鲜期                         |          | √        | √        |          |
|                       | 验证与重载相关                                               |          |          |          |          |
| `must-revalidate`     | 使用缓存资源执勤啊，必须要先验证状态，且过期资源不应该再使用 |          | √        |          | √        |
| `proxy-revalidate`    | 同上，同样只对代理服务器生效，同样如果是 `private` 缓存，忽略该字段 |          | √        |          | √        |
|                       | 其他                                                         |          |          |          |          |
| `no-store`            | 请求和响应都不缓存                                           | √        |          | √        | √        |
| `only-if-cached`      | 仅返回已经缓存的资源，不再向服务器获取新的内容，若无缓存则返回 504 |          |          | √        |          |
| `no-transform`        | 强制要求代理服务器不要对资源进行转换，禁止代理服务器对 `Content-Encoding\Content-Range\Content-Type` 字段的修改（因此代理的 `gzip` 压缩将不被允许） |          |          | √        | √        |

* 主要作用其实就是 `max-age=0` 不使用强缓存，但使用协商缓存
  * 对 `max-age>0` 各个浏览器的支持程度并不好，有可能出现请求的 `max-age` 小于响应的 `max-age` 的情况，但理论山如果请求的小的，那么就应该只缓存小于该请求值的的响应的数据
  * 响应中的 max-age 和 Expires 作用有些类似，但优先级高于 Expires，因此设置 max-age会忽略 Expires
  * no-cache 和 no-store ，no-cache 指跳过强缓存，强制进入协商策略，no-store 是指不缓存文件
* Pragmaagma：HTTP1.0 字段，通常设置为 `Pragma:no-cache`，作用与 `Cache-Control:no-cache` 相同。浏览器强行刷新就会带上这两个字段并且不会带上协商策略相关的东西。即不使用任何缓存
* Last-Modified/If-Modified-Since/If-Unmodified-Since：
  * 语法格式类似 Expires，需要 GMT 格式的时间点，因此也不适合 1 秒内多次改变缓存
  * 如果上述的 Expires 、Cache-Control:max-age、Cache-Control:s-max-age 等都没有出现在响应头，并且设置了 Last-Modified ，那么浏览器默认会采用一个启发式算法，即**启发式缓存**。通常会取响应头的Date 和 Last-Modified 之间的差值的 10% 作为缓存时间周期，也就是即使此时之后断网且强缓存失效，也是可以读取缓存文件的（其实就相当于强缓存了）
  * 当返回的资源带有 Last 时，再次请求该资源时，浏览器会自动带上 `If-Modified-Since` ，值为返回的 Last 的值，如果未更新内容返回 304，如果更新了重新返回 Last ，注意该请求头只能用于 GET、POST
  * 304 请求也可以触发存储策略
  * If-Unmodified-Since 表示资源未修改则正常执行更新，否则返回 412 ( Precondition Faild ) 状态码
    * 用于不安全的请求中，从而使请求具备条件性（ 比如POST ），如请求更新 wiki 文档，文档未修改时才执行更新
    * 与 If-Rand 字段同时使用，可以保证新的片段请求来自一个未修改的文档
    * 总之就是需要不更改的数据，否则报个错
  * ETag / If-Match / If-None-Match
    * ETag 是请求资源在服务器的唯一标识，浏览器可以根据 ETag 值缓存数据，在再次请求时通过 `If-None-Match` 携带上次的 ETag 值，如果值不变就返回 304，如果改变就返回新内容。`If-Match` 与之相反的逻辑，类似于上文的 Unmodified
    * 需要注意，ETag 及两个 Match 的内容都是用双引号包裹的
    * ETag 的优先级默认比 Last-Modified 高，但可以用服务端设置哪个优先级更高

1. 各类缓存的优缺点：

   | 缓存头部      | 优点                                                         | 缺点                                                         |
   | ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | Expires       | 1. HTTP1.0 产物，可以在 1.0 和 1.1 中使用；2. 简单易用，通过绝对时间标识失效时间 | 1. 本地时间和服务器时间不一致很可能会出问题；2. 存在版本问题，资源过期前的任何修改客户端无法感知 |
   | Cache-Control | 1. HTTP1.1 的内容，以相对时间标识失效时间，解决了 Expires 服务器和客户端相对时间的问题；2.支持指令多，可以根据需求配置 | 1.不适用与1.0的内容；2.与 Expires 类似存在不过期就无法感知修改的问题 |
   | Last-Modified | 1. 不存在版本问题，每次都校验，符合 304，不符合返回资源      | 1. 以时刻做标识，精确到秒，无法识别 1 秒内多次修改的情况；2.只要资源修改，无论是否实质变化都会重发资源 |
   | ETag          | 1. 不存在版本问题，每次都会校验，符合 304，不符合返回资源；2. 可以更精确判断资源是否被修改；3. 可以识别一秒内多次修改的情况 | 1. 计算 ETag 消耗性能；2. 分布式服务器存储会导致 ETag 算法可能不一致，导致验证不通过 |

   

2. 缓存的最佳实践

   * 目前的最佳实践：
     1. 不要缓存 **HTML**，避免缓存后用户无法及时获取到更新内容（很有可能就是强缓存）（不用 Expires）
     2. 使用`Cache-Control`和`ETag`来控制HTML中所使用的静态资源的缓存。一般是将`Cache-Control`的`max-age`设置成一个比较大的值（存活期长，一般和 no-cache 搭配，不使用强缓存），然后用`ETag`验证（一旦修改就重发）
     3. 使用签名或版本来区分静态资源。这样静态资源会生成不同的资源访问链接，不会产生修改之后无法感知的情况（这就是为什么需要带 hash 的原因，不会产生修改后无法感知的情况，猜测 ETag 和名字里面的版本号计算都需要消耗部分资源，而且 ETag 需要验证的话会容易导致分布式服务器验证的问题）
   * 不建议的情况：使用 HTML 的 meta 标签指定缓存行为；使用查询字符串来避免缓存，因为缓存一些已知的（？）问题，使用查询字符串会导致有些代理服务器不缓存资源

3. 测试一下：**需要继续看**

### 明日计划

* 复习原型、复习部分网络的知识（重点可能是基础概念）
* 把今天没看完的看完，没写完的写一写