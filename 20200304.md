### this 复习

* this 的定义和作用：this 是 JS 的面向对象编程中的关键字，通常用于指向类实例化后的对象本身，但由于设计糟糕，所以要分情况考虑
* this 的特性：call、apply、bind 的第一个参数都能改变方法的 this，注意绑定过的函数的结果不能重新绑定
* this 在不同情况下的表现
  * 类内：实例化后，指向实例化的对象本身
  * 对象的方法：指向对象本身，注意如果对象的方法被传给一个外部的变量，那么this指向也就变成外部那个变量本身的 this 指向，也不要嵌套，嵌套在里层的普通函数指向的也是全局变量
  * function 函数内：指向全局变量，如果用于当作构造函数，那么也是实例化的对象本身
  * 箭头函数内：静态作用域，指向函数外层最近一层的this，如果箭头函数是在全局定义，那么就指向全局对象（window、global）
  * 全局作用域，指向全局对象（window、global）

### 事件模型

* 事件对象：在绑定事件处理器后，事件处理器在调用时会被传入事件对象event，并且浏览器会创建一个window.event，在处理完成后销毁

* 冒泡：祖先元素上的事件处理器会在后代元素发生相应事件后也会被调用，并且一直逐级往外抛出直到document和window上，可以用event.stopPropagation停止冒泡
* 捕获：与冒泡相反，组件元素在事件捕获阶段就触发，使用stopImmediatelyPropagation阻止继续捕获，因为即便当前的发生的捕获被阻止了，其他元素还会继续往下传播事件
* 目标阶段：事件在真正发生的节点上被监听到并运行事件处理器
* 事件代理/事件委托：将事件绑定在祖先元素上，使用event.target判断后代元素，简化对后代元素事件的绑定
* 模型：捕获阶段-> 目标阶段 -> 冒泡阶段

### 事件循环

* eventloop：先进先出队列，分成不同阶段执行，需要消耗完当前的队列或者回调执行到最大值极限（单次进入阶段时执行回调的上限，会有个很大的上限），才会接着下一个阶段
* 微任务宏任务：微任务运行在阶段的间隙，随时插入，队列会直接执行且不会循环，宏任务运行在阶段之中，不可随时插入，因此会循环再执行（浏览器和Node 的对此的处理稍有不同）
  * process.nextTick微任务，因此在各个阶段的间隙运行
  * then也是微任务，但规定在process.nextTick后面
  * 浏览器有setTimeout和
* 几个阶段：
  * timers：执行 setTimeout 和 setInterval，时间限制，超时以后才尽快执行，因此不会精确（会受上一次poll的影响）
  * pending ：系统操作的回调，比如 TCP errors，比如 TCP 报错 ECONNREFUSED
  * idle，node 内部的一些异步操作
  * poll：找回新IO事件（估计就是接入新的IO）（等待着可以执行的东西执行），比如fs.readFile 的回调，两个步骤：计算 timers 最多需要等待的时间，并处理队列，如果队列不为空，就执行直到队列完成或队列极限；如果队列为空：有 setImmediately，那么离开并执行 check 阶段，如果没有，那么就在这等着直到有新的 callback 进入就单线程执行掉，直到等待时间结束；注意如果在回调里面再放一个该阶段的回调也只会在下阶段执行，符合宏任务的特点 
  * check：执行 setImmediately 等
  * close callback：关闭的回调，比如`socket.on('close', ...)`
* await 会把得到的结果包装成 Promise，await 之后的语句会当做 Promise.then() 里的语句执行
* 宏任务，setTimout、setInterval、setImmediately、requestAnamtionFrame
* 微任务，process.nextTick、Promise.then、MutaionObserver
* `NodeJS` 和浏览器里的 `then` 不太一样，Node 里面的 `process.nextTick` 优先级明显比 `then` 高，有待文档或 stackoverflow 里求证

### 一文搞懂浏览器缓存策略

1. 缓存的判断策略

   * 主要包含以下三种策略：**存储策略**、**过期策略**、**协商策略**

   * 存储策略发生在收到请求响应后，用于决定是否缓存相应资源

   * 过期策略发生在请求前，用于判断缓存是否过期

   * 协商策略发生在请求中，用于判断缓存资源是否更新（比如 304 Not Modified ）

   * ![](E:\1.FrontEnd\浏览器缓存流程.jpg)

   * 浏览器发起请求 -> 是否有缓存 -> 向服务器请求资源 -> **存储策略**：响应内容存入缓存 -> 载入资源

     ​			|														|																					|

     **过期策略**：判断缓存是否过期 -> **协商策略**：向服务端发起验证，验证资源是否有效 -> 304响应

     * 怎么判断过期？计算文件日期（Exprires等响应头）？怎么发起验证？另外的验证资源请求？怎么发起（不发起另外的，直接就是根据响应做判断）？如果304响应又该怎么做（存储策略响应）？怎么存入，存到哪里（Chrome是根据派生和主资源的方式方式存到disk或memory中）？

   * 根据浏览器中访问资源方式的不同也会导致判断流程的不同，**判断流程会根据不同方式跳过一些流程**

   * 浏览器访问资源的方式主要是以下7种

     1. 新标签/地址栏回车
     2. 链接跳转(**window.location 赋值或 replace 算吗？**)（应该算，需要验证）
     3. 前进后退
     4. 收藏栏打开
     5. window.open 打开新窗口
     6. 刷新（F5）
     7. 强制刷新（Ctrl+F5）

   * 前面5种正常流程，刷新直接到协商策略，强制刷新直接请求资源

   * Chrome地址栏不改变内容回车想相当于刷新，FireFox等别的不变
   * 主资源和派生资源：主资源是地址栏输入的URL请求返回的资源（**有什么呢？HTML？**），派生资源是主资源所引用的JS、CSS、图片等资源（**我记得有种常见的是吧JS、CSS、图片等的名称中加一串hash，说是可以防止缓存，这是为什么呢？**），Chrome刷新时，只有主资源缓存方式走上述刷新流程，派生资源的缓存应用方式与新标签打开类似，会判断是否过期。强缓存生效时的区别在于新标签打开为`from disk cache`，而当前页面刷新派生资源`from memory cache`
   * FireFox（Gecko），EdgeHTML(Trident，后来改成webkit了)，Blink是现在魔改版的webkit

2. 必知必会的缓存基础

   * 与缓存相关的HTTP字段（10个）（包含存储策略、过期策略、协商策略、请求头、响应头）
   * **需要继续看**

3. 各类缓存的优缺点：**需要继续看**

4. 缓存的最佳实践

   * 目前的最佳实践：
     1. 不要缓存HTML，避免缓存后用户无法及时获取到更新内容（很有可能就是强缓存）
     2. 使用`Cache-Control`和`ETag`来控制HTML中所使用的静态资源的缓存。一般是将`Cache-Control`的`max-age`设置成一个比较大的值，然后用`ETag`验证
     3. 使用签名或版本来区分静态资源。这样静态资源会生成不同的资源访问链接，不会产生修改之后无法感知的情况（这就是为什么需要带 hash 的原因，不会产生修改后无法感知的情况，猜测 ETag 和名字里面的版本号计算都需要消耗部分资源，而且 ETag 需要验证的话会容易导致分布式服务器验证的问题）
   * 不建议的情况：使用 HTML 的 meta 标签指定缓存行为；使用查询字符串来避免缓存，因为缓存一些已知的（？）问题，使用查询字符串会导致有些代理服务器不缓存资源

5. 测试一下：**需要继续看**

### 明日计划

* 复习原型、复习部分网络的知识（重点可能是基础概念）
* 把今天没看完的看完，没写完的写一写