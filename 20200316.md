### 面试题
* ES5 和 ES6 的继承问题？
```
ES5 构造函数 super 构造父类的对象，并在这个对象上修改
ES6 不仅继承了原型对象，而且继承了静态方法和属性
```
* 对于原生 JS 的理解
```
解释型语言
异步 IO
语言类型特征
函数式编程的体现（比如原型体系，函数即对象等等）

```
* 对于 TypeScript 的理解
```
类型检查
灵活的类型编辑（比如泛型，比如联合类型等等）
接口、枚举、
声明文件
ES6 及超前的语法支持（比如 ?. 操作符）
```
* JS 的几种迭代语法在 Chrome 等现代浏览器中的性能差异
```
需要实际测试
for forof forin forEach while dowhile 等等
多次执行性能是否有优化
++和--的区别
遍历时查找原型链（猜测时 forin 这样的）
```
* 如何提升 JS 变量的存储性能
```
局部变量和全局变量的访问位置和访问速度
访问不同变量，比如字面量、对象属性等等情况是否也有不同
with 和 catch 关键字对访问造成的影响
多次执行性能是否有优化
```
* Node.js 和浏览器中事件循环机制的不同
```
event loop
微任务宏任务
```
* 比较 TS 和 JS ，在什么情况你觉得需要 TS
```
多人、多文件、多次引用和嵌套，返回复杂类型的情况
```

* 在 JS 中如何实现对象的私有属性
```
参考资料：https://www.cnblogs.com/ihardcoder/p/4914938.html
新特性 # 可以实现类实例化时创建私有属性
使用闭包在构造函数上实现，特权函数和闭包属性，存在缺陷，因为特权函数和私有变量理应在 protype上创建，让所有实例访问同一个而不是每个实例都创建一个，浪费资源
使用立即执行函数里的闭包和Map（有缺陷，因为常数 key 可能不会被销毁）、WeakMap（弱引用，可以使用 this 当做 key ，因此可以被销毁）
使用 Proxy
	使用 construct 包裹每个变量
私有 + Symbol 
var C = (function () {
	var _name = Symbol()
	return class A {
		constructor(name) {
			this[_name] = name
		}
	}
}())
使用 _ 前缀？编码规范
```
* JS 中实现继承的几种方式？
```
构造函数模式：可以创建不同实例属性的副本，包括引用类型的实例属性，但是不能共享方法	
function Person(name) {
  this.name = name
  this.getName = () => { return this.name }
  // 因为是构造函数直接在 this 上挂载的，所以该方法一个对象上一个，不能复用
  // var b = new Person('John'), a = new Person('Jane')
  // b.getName !== a.getName // true
}
原型模式：引用类型的属性，对于实例对象而言共享一个物理空间（就是存储的是一个指针），因此可以共享方法（函数）
// 仍然是属性独立存在
function Person(name) {
  this.name = name
}
// 方法共享了
Person.prototype.getName = function () {
	return this.name
}
原型链：对父类实现方法和属性继承的过程中，父类实例对象的应用类型属性在子类的实例中共享同一个物理空间，因此父类的实例对象指向了子类的原型对象，也因此如果子类修改了引用属性内的值做了修改，那么所有子类都会得到修改的结果
借用构造函数
组合继承
寄生组合继承
ES6 的 extends 和 super：实质上是使用 super 创建父类的实例，因此如果使用这一方法必须先调用 super 创建父类实力，然后才能再调用 this 并添加方法、属性等等
```

*  
